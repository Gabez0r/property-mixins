<script>
  /**
   * Mixin that provides color-properties
   *
   * @mixinFunction
   * @polymer
   */
  const ColorMixin = (superClass) => { // eslint-disable-line no-unused-vars no-undef

    return class extends superClass {

      constructor() {
        super();
        this._regExpRGBA = /\s*rgba?\(\s*(?:(25[0-5]|2[0-4]\d|1\d{1,2}|\d\d?)\s*,\s*(25[0-5]|2[0-4]\d|1\d{1,2}|\d\d?)\s*,\s*(25[0-5]|2[0-4]\d|1\d{1,2}|\d\d?))?(#(?:[a-f0-9]{6}|[a-f0-9]{3}))?\s*,?\s*([01]\.?\d*?)?\)/i;
        this._regExpHex = /\s*(#(?:[a-f0-9]{6}|[a-f0-9]{3}))/i;
      }

      static get properties() {
        return {
          /**
           * hex-color
           */
          hex: {
            type: String,
            notify: true
          },
          /**
           * rgb-color
           */
          rgb: {
            type: Array,
            notify: true
          },
          /**
           * alpha-value
           */
          alpha: {
            type: Number,
            notify: true,
            value: 1
          },
          /**
           * hex-color
           */
          value: {
            type: String,
            notify: true,
            observer: '_valueChanged'
          }
        }
      }

      static get observers() {
        return [
          '_rgbChanged(rgb, alpha)',
          '_hexChanged(hex, alpha)'
        ];
      }

      _valueChanged(value, oldValue) {
        if (value === undefined) return;

        let test = this._regExpRGBA.exec(value),
          rgb = [],
          hex,
          alpha = 1,
          toSet = {};

        if (test !== null) {
          if (test[4] !== undefined) {
            hex = test[4];
            rgb = this.hexToRgb(hex);
          } else if (test[1] !== undefined && test[2] !== undefined && test[3] !== undefined) {
            rgb = [test[1], test[2], test[3]];
            hex = this.rgbToHex(rgb);
          }
          if (test[5] !== undefined) {
            alpha = +test[5];
          }
        } else {
          hex = this._regExpHex.exec(value);
          if (hex !== null) {
            hex = hex[1];
            rgb = this.hexToRgb(hex);
            alpha = 1;
          }
        }
        if (hex) {
          if (this._arrayEqual(this.rgb, rgb) === false) {
            toSet.rgb = rgb;
          }
          if (this.hex !== hex) {
            toSet.hex = hex;
          }
          if (alpha !== undefined && this.alpha !== alpha) {
            toSet.alpha = alpha;
          }
          this.setProperties(toSet);
        // } else if (value && oldValue && value !== oldValue) {
        //   console.log('oldValue', oldValue);
        //   this.value = oldValue;
        // } else if (this.hex && (test === null || test[4] !== undefined)) {
        //   this._hexChanged(this.hex, this.alpha)
        // } else if (this.rgb) {
        //   this._rgbChanged(this.rgb, this.alpha)
      } else if (oldValue) {
          this._valueChanged(oldValue); // provide at hex, rgb, values to be reset when wrong
        }
      }

      _hexChanged(hex, alpha) {
        hex = this._regExpHex.exec(hex);
        if (hex === null) {
          if (this.value) {
            this._valueChanged(this.value);
          }
          return;
        }
        hex = hex[1];
        if (alpha === undefined || alpha > 1) {
          alpha = 1;
          return;
        } else if (alpha < 0) {
          alpha = 0;
          return;
        }
        alpha = +alpha;
        const valueHasHex = Boolean(this.value === undefined || this._regExpHex.exec(this.value));
        const str = valueHasHex ? hex : this.hexToRgb(hex).join(',');
        if (str) {
          if (alpha === 1) {
            this.value = valueHasHex ? str : `rgb(${str})`;
          } else {
            this.value = `rgba(${str},${alpha})`;
          }
        } else if (this.value !== undefined) {
          this._valueChanged(this.value)
        }
      }

      _rgbChanged(rgb, alpha) {
        if (!(Array.isArray(rgb) && rgb.length === 3 && rgb.every(e => {
            return !isNaN(e) && e >= 0 && e < 256;
          }))) {
          if (this.value) {
            this._valueChanged(this.value);
          }
          return;
        }
        if (alpha === undefined || alpha > 1) {
          alpha = 1;
        } else if (alpha < 0) {
          alpha = 0;
        }
        alpha = +alpha;
        const valueHasHex = Boolean(this.value === undefined || this._regExpHex.exec(this.value));
        const str = valueHasHex ? this.rgbToHex(rgb) : rgb.join(',');
        if (str) {
          if (alpha === 1) {
            this.value = valueHasHex ? str : `rgb(${str})`;
          } else {
            this.value = `rgba(${str},${alpha})`;
          }
          return;
        } else if (this.value !== undefined) {
          this._valueChanged(this.value)
        }
      }

      /**
       * generate random rgb-color
       * @return {[array]} rgb-value array
       */
      _randomRGB() {
        return [Math.round(255 * Math.random()), Math.round(255 * Math.random()), Math.round(255 * Math.random())];
      }

      random() {
        this.set('rgb' ,this._randomRGB());
      }

      hexToRgb(hex) {
        hex = this._regExpHex.exec(hex);
        if (hex === null) return;

        hex = hex[1].replace('#', '');
        if (hex.length === 3) {
          hex = hex.replace(/(.)(.)(.)/, "$1$1$2$2$3$3");
        }

        return [parseInt(hex.substr(0, 2), 16), parseInt(hex.substr(2, 2), 16), parseInt(hex.substr(4, 2), 16)];
      }

      rgbToHex(rgb) {
        if (!(Array.isArray(rgb) && rgb.length === 3 && rgb.every(e => {
            return !isNaN(e) && e >= 0 && e < 256;
          }))) {
          return;
        }

        const _componentToHex = function(component) {
          const _hex = component.toString(16);
          if (_hex.length === 1) {
            return `0${_hex}`;
          } else {
            return _hex;
          }
        };

        return '#' + [_componentToHex(+rgb[0]), _componentToHex(+rgb[1]), _componentToHex(+rgb[2])].join('');
      }

      _arrayEqual(a, b) {
        if (!(Array.isArray(b) && b.every(e => {
            return !isNaN(e)
          }))) {
          return;
        }
        if (!(Array.isArray(a))) {
          return false;
        }
        for (let i = 0; i < a.length; i++) {
          if (a[i] !== b[i])
            return false;
        }
        return true;
      }
    }
  }

  window.ColorMixin = ColorMixin;
</script>
